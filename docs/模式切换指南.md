# 工作流模式切换指南

## 概述

AI陪伴机器人工作流支持三种运行模式，可以通过环境变量自由切换：

1. **完整模式**（full_companion）- 默认，性能最优
2. **可视化模式**（detailed）- 步骤级拆分，类似扣子工作流
3. **实时通话模式**（realtime_call）- 低延迟，用于实时对话

---

## 模式对比

| 模式 | 节点数 | 可视化粒度 | 性能 | 适用场景 |
|------|--------|-----------|------|---------|
| **完整模式** | 7个 | 节点级 | ⭐⭐⭐⭐⭐ | 生产环境 |
| **可视化模式** | 20+个 | 步骤级 | ⭐⭐⭐ | 开发/展示/调试 |
| **实时通话模式** | 3个 | 节点级 | ⭐⭐⭐⭐⭐ | 实时对话 |

---

## 模式详情

### 1. 完整模式（full_companion）

**特点：**
- 性能最优（零节点间通信开销）
- 可视化简洁（7个主要节点）
- 适合生产环境

**节点结构：**
```
输入 → 路由决策
  ├─ 主动关心 → TTS → 保存记忆
  ├─ 作业提醒 → TTS → 保存记忆
  ├─ 口语练习（单节点）→ TTS → 保存记忆
  └─ 实时对话（单节点）→ TTS → 保存记忆
```

**使用方法：**
```bash
# 默认模式，无需设置环境变量
export COZE_GRAPH_MODE=full_companion
```

---

### 2. 可视化模式（detailed）⭐ 推荐

**特点：**
- 步骤级可视化，类似扣子工作流
- 清晰展示每个处理步骤
- 便于理解和调试
- 性能略有损失（~300-500ms额外开销）

**节点结构：**
```
输入 → 路由决策
  ├─ 主动关心 → TTS → 保存记忆
  ├─ 作业提醒 → TTS → 保存记忆
  ├─ 口语练习（7个步骤）
  │   ├─ 1. 语音识别（ASR）
  │   ├─ 2. 复习检查（间隔重复算法）
  │   ├─ 3. 场景选择
  │   ├─ 4. 对话引擎（四阶段）
  │   ├─ 5. 知识点识别
  │   ├─ 6. 更新记忆
  │   └─ 7. TTS合成
  └─ 实时对话（5个步骤）
      ├─ 1. 搜索判断
      ├─ 2. 联网搜索
      ├─ 3. 上下文构建
      ├─ 4. LLM生成
      └─ 5. 作业意图识别
```

**使用方法：**
```bash
export COZE_GRAPH_MODE=detailed
```

**性能影响：**
- 增加节点间通信：13次
- 额外开销：~300-500ms
- 对总响应时间影响：~8-15%

---

### 3. 实时通话模式（realtime_call）

**特点：**
- 极低延迟（1-2秒响应）
- 精简节点（仅ASR→LLM→TTS）
- 适合实时对话场景

**节点结构：**
```
输入 → ASR → LLM → TTS → 输出
```

**使用方法：**
```bash
export COZE_GRAPH_MODE=realtime_call
```

---

## 如何切换模式

### 方法1：临时切换（当前会话）

```bash
# 切换到可视化模式
export COZE_GRAPH_MODE=detailed

# 重启服务
python src/main.py
```

### 方法2：永久切换（写入环境变量）

**Linux/Mac:**
```bash
# 添加到 ~/.bashrc 或 ~/.zshrc
echo 'export COZE_GRAPH_MODE=detailed' >> ~/.bashrc
source ~/.bashrc
```

**Windows (PowerShell):**
```powershell
# 添加到环境变量
[System.Environment]::SetEnvironmentVariable('COZE_GRAPH_MODE', 'detailed', 'User')
```

**Windows (CMD):**
```cmd
setx COZE_GRAPH_MODE detailed
```

### 方法3：Docker环境

**Docker Compose:**
```yaml
services:
  app:
    environment:
      - COZE_GRAPH_MODE=detailed
```

**Docker Run:**
```bash
docker run -e COZE_GRAPH_MODE=detailed your-image
```

---

## 验证当前模式

启动服务后，查看日志输出：

**完整模式：**
```
✅ COZE_GRAPH_MODE=full_companion: 使用完整陪伴机器人模式
   性能优化模式，适合生产环境
```

**可视化模式：**
```
============================================================
✅ COZE_GRAPH_MODE=detailed: 已切换到可视化模式
   工作流已拆分为步骤级节点，清晰展示每个处理步骤
   - 口语练习: 7个步骤节点
   - 实时对话: 5个步骤节点
   - 主动关心: 1个节点
   - 作业提醒: 1个节点
============================================================
```

**实时通话模式：**
```
✅ COZE_GRAPH_MODE=realtime_call: 已切换到低延迟实时通话模式
```

---

## 可视化效果对比

### 完整模式（7个节点）
```
┌─────────────┐
│  加载记忆   │
└─────────────┘
       ↓
┌─────────────┐
│  路由决策   │
└─────────────┘
       ↓
┌─────────────┐
│ 口语练习    │  ← 包含7个步骤，但只显示一个节点
└─────────────┘
       ↓
┌─────────────┐
│   TTS       │
└─────────────┘
```

### 可视化模式（20+个节点）
```
┌─────────────┐
│  加载记忆   │
└─────────────┘
       ↓
┌─────────────┐
│  路由决策   │
└─────────────┘
       ↓
┌─────────────┐
│ 1. ASR      │  ← 每个步骤都独立显示
└─────────────┘
       ↓
┌─────────────┐
│ 2. 复习检查 │
└─────────────┘
       ↓
┌─────────────┐
│ 3. 场景选择 │
└─────────────┘
       ↓
┌─────────────┐
│ 4. 对话引擎 │
└─────────────┘
       ↓
...（更多步骤）
```

---

## 推荐使用场景

### 使用完整模式（full_companion）
- ✅ 生产环境部署
- ✅ 需要最佳性能
- ✅ 用户量大，响应速度要求高
- ✅ 对可视化要求不高

### 使用可视化模式（detailed）
- ✅ 开发和调试
- ✅ 向他人展示工作流逻辑
- ✅ 学习和理解工作流结构
- ✅ 排查问题时需要追踪每个步骤
- ✅ 演示和培训

### 使用实时通话模式（realtime_call）
- ✅ 实时对话场景
- ✅ 对延迟要求极高
- ✅ 不需要复杂的功能（作业、记忆等）
- ✅ 简单对话交互

---

## 常见问题

### Q1: 切换模式会影响数据吗？
**A:** 不会。三种模式使用相同的存储（MemoryStore），数据完全兼容。

### Q2: 切换模式需要重启服务吗？
**A:** 是的。修改环境变量后需要重启服务才能生效。

### Q3: 可视化模式会丢失数据吗？
**A:** 不会。所有功能都保留，只是拆分为多个节点。

### Q4: 性能损失多少？
**A:** 可视化模式的额外开销约为300-500ms，对总响应时间的影响约为8-15%。例如：
- 完整模式：3.8秒
- 可视化模式：4.1-4.3秒

### Q5: 可以自定义拆分方式吗？
**A:** 可以。修改 `src/graphs/visual_graph.py` 和 `src/graphs/visual_node.py` 即可。

### Q6: 如何回退到默认模式？
**A:** 删除环境变量或设置为 `full_companion`，然后重启服务。

---

## 技术细节

### 完整模式架构
- **文件：** `src/graphs/graph.py`, `src/graphs/node.py`
- **节点数：** 7个
- **状态：** `GlobalState`
- **节点间通信：** 0次

### 可视化模式架构
- **文件：** `src/graphs/visual_graph.py`, `src/graphs/visual_node.py`, `src/graphs/visual_state.py`
- **节点数：** 20+个
- **状态：** `VisualGlobalState`（继承自GlobalState）
- **节点间通信：** 13次

### 实时通话模式架构
- **文件：** `src/graphs/realtime_call_graph.py`
- **节点数：** 3个
- **状态：** 简化版GlobalState
- **节点间通信：** 0次

---

## 快速切换示例

### 开发时使用可视化模式
```bash
# 切换到可视化模式
export COZE_GRAPH_MODE=detailed

# 启动服务
python src/main.py

# 查看可视化效果
# 访问 http://localhost:8000/visual
```

### 生产环境使用完整模式
```bash
# 切换到完整模式
export COZE_GRAPH_MODE=full_companion

# 启动服务
python src/main.py
```

### 实时对话使用实时通话模式
```bash
# 切换到实时通话模式
export COZE_GRAPH_MODE=realtime_call

# 启动服务
python src/main.py
```

---

## 总结

三种模式各有优势，根据场景选择：

| 场景 | 推荐模式 | 原因 |
|------|---------|------|
| 生产环境 | full_companion | 性能最优 |
| 开发调试 | detailed | 可视化清晰 |
| 向他人展示 | detailed | 步骤级展示 |
| 实时对话 | realtime_call | 低延迟 |

**建议：**
- 日常开发：使用 `detailed` 模式，清晰看到每个步骤
- 上线部署：切换回 `full_companion` 模式，提升性能
- 特殊场景：根据需求临时切换到 `realtime_call` 模式

---

## 相关文档

- [节点内部流程说明](./节点内部流程说明.md)
- [可视化优化说明](./可视化优化说明.md)
- [使用指南](./使用指南.md)
